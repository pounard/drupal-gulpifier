<?php

/**
 * Implements hook_form_FORM_ID_alter().
 */
function gulpifier_form_system_performance_settings_alter(&$form) {

  $form['gulpifier'] = array(
    '#type'  => 'fieldset',
    '#title' => t("Gulpifier"),
  );
  $form['gulpifier']['gulpifier_nocachebuster'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Prevent asset cache busting"),
    '#description'   => t("In this mode, the GET parameter appended to assets (?123456789) will be removed, allowing you to edit in the broser."),
    '#default_value' => variable_get('gulpifier_nocachebuster', FALSE),
  );
  $form['gulpifier']['gulpifier_discover'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable JS discovery"),
    '#description'   => t("In this mode, a JSON map of the JS files used will be built upon each page request. You can manually edit it to exclude some files, or reorder the files between them."),
    '#default_value' => variable_get('gulpifier_discover', FALSE),
  );
  $form['gulpifier']['gulpifier_map_path'] = array(
    '#type'          => 'textfield',
    '#title'         => t("Path to the map.json file"),
    '#description'   => t("The path to the JSON map relative to the theme. It is advised to track it within your VCS, most probably in the theme."),
    '#default_value' => variable_get('gulpifier_map_path', '/js'),
  );
  $form['gulpifier']['gulpifier_single_js'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single JS file (production mode)"),
    '#description'   => t("In this mode, all JS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => variable_get('gulpifier_single_js', FALSE),
  );
  $form['gulpifier']['gulpifier_single_css'] = array(
    '#type'          => 'checkbox',
    '#title'         => t("Enable single CSS file (production mode)"),
    '#description'   => t("In this mode, all CSS files that are not in the whitelist are removed, and replaced with the one generated by Gulp."),
    '#default_value' => variable_get('gulpifier_single_css', FALSE),
  );

  $form['#validate'][] = 'gulpifier_form_system_performance_settings_validate';
}

/**
 * Validate the gulpifier settings.
 *
 * @param $form
 * @param $form_state
 */
function gulpifier_form_system_performance_settings_validate(&$form, &$form_state) {
  // @TODO validate the map.json path
}

/**
 * Prevent files we don't handle from being processed.
 *
 * @param string $name
 * @param mixed $settings
 * @param string|string[] $ignore
 *
 * @return boolean
 */
function gulpifier_match($name, $settings, $ignore = array()) {
  if (!is_array($ignore)) {
    $ignore = array($ignore);
  }
  if (in_array($name, $ignore)) {
    return false;
  }
  if ('settings' === $name) {
    return false; // Ignore Drupal.settings.
  }
  if (FALSE !== strstr($name, 'languages/')) {
    return false; // Ignore Drupal.t sources.
  }
  if ('external' === $settings['type']) {
    return false; // Ignore external code.
  }
  if ('inline' === $settings['type']) {
    return false; // Ignore inline code.
  }
  return true;
}

/**
 * Implements hook_js_alter().
 */
function gulpifier_js_alter(&$js) {
  global $theme;

  if (!theme_get_setting('gulpifier')) {
    return;
  }

  $theme_path = drupal_get_path('theme', $theme);

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($theme, 'js');

  $discover_enabled = variable_get('gulpifier_discover', FALSE);

  // Get the bundle script path.
  $script_path = variable_get('gulpifier_js_bundle_path', $theme_path . '/dist') . '/script.min.js';

  $map_path = theme_get_setting('map_path');
  if (!$map_path) {
    $map_path = variable_get('gulpifier_map_path', '/js');
  }
  $map_path = $theme_path . '/' . trim($map_path, "/") . '/map.json';

  $map = gulpifier_load_map($map_path);

  if ($discover_enabled) {
    if (gulpifier_discover_js($js, $map, $script_path, $whitelist)) {
      // Udpate when necessary map.json
      $json = json_encode($map, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
      file_put_contents($map_path, $json);
    }
  }

  // A single JS file means we work in a production environment, so include only
  // our single JS file, generated by gulp, and those from the whitelist. When
  // not in single mode, our single file will be excluded.
  if (variable_get('gulpifier_single_js', FALSE)) {

    foreach ($js as $name => $settings) {
      // Exclude all files except for our own, and Drupal.settings
      if (gulpifier_match($name, $settings, $script_path) && !in_array($name, $whitelist, TRUE)) {
        unset($js[$name]);
      }
      else {
        // Force every script to be in the same scope. In that way, we could
        // render them all together anywhere we want.
        $js[$name]['scope'] = 'header';
        // Use the same group for all JS to have a single bundle.
        $js[$name]['group'] = JS_DEFAULT;
      }
    }

    // Change its group and weight to be the first one included.
    // In that way, all other scripts whitelist don't have to take care about
    // group and weight regarding to this global aggregate scripts which may
    // contains library.
    $js[$script_path]['group'] = JS_LIBRARY;
    $js[$script_path]['preprocess'] = FALSE;
    $js[$script_path]['weight'] = -900;
  }
  else {
    if (isset($js[$script_path])) {
      unset($js[$script_path]);
    }
    // Also when running normal operations, we need to exclude settings that
    // are set to strict false into the map, in order to have the exact same
    // JS code whether the aggregation is set or not.
    foreach ($js as $name => $settings) {
      if ($discover_enabled) {
        if (isset($map[$name]) && !$map[$name]) {
          unset($js[$name]);
        }
      } else {
        if (!isset($map[$name]) || !$map[$name]) {
          unset($js[$name]);
        }
      }
    }
  }
}

/**
 * Get cleaned whitelist
 *
 * @param $front_theme
 * @param $type
 *  'js' or 'css'
 * @return array
 */
function gulpifier_get_whitelist($theme, $type) {

  $whitelist = &drupal_static(__FUNCTION__, NULL);
  $whitelist = (array) theme_get_setting('gulpifier_whitelist', $theme);

  // Transform the module_name:path notation
  foreach ($whitelist as &$file) {
    if (FALSE !== strstr($file, ':')) {
      list($module, $path) = explode(':', $file, 1);
      $file = drupal_get_path('module', $module) . $path;
    }
  }

  return isset($whitelist[$type]) ? $whitelist[$type] : array();
}

/**
 * Load theme path map.
 *
 * @param string $theme
 *
 * @return array
 */
function gulpifier_load_map($map_path) {

  // Load previous list
  $contents = @file_get_contents($map_path);
  $list = FALSE;
  if ($contents !== FALSE) {
    // We have a list, parse it
    $list = drupal_json_decode($contents);
  }

  // else reading file failed, and we won't update it programmatically, but
  // we will still remove our single file
  if (!$list) {
    $list = array();
  }

  return $list;
}

/**
 * Populate a map.json with the JS files of the current page
 *
 * During discovery, we will try to populate the map.json file
 * with JS files that are included on each page of the site.
 *
 * @param array $js
 *  The big JS array of the current page provided by Drupal
 * @param array $map
 *  The JSON map file path
 * @param string $script_path
 *  The minified JS file path
 * @param array $whitelist
 *  The JS whitelist from the theme .info file
 *
 * @return boolean
 *  True if modified.
 */
function gulpifier_discover_js($js, &$map, $script_path, $whitelist) {
  $modified = false;
  foreach ($js as $name => $settings) {
    // If we have a list, update it
    if (gulpifier_match($name, $settings) && $map !== FALSE && !in_array($name, $whitelist, TRUE)) {
      // TRUE will add it, FALSE will remove it, edit the map.json file
      // directly if you need to exclude a file
      if (!isset($map[$name])) {
        $map[$name] = true;
        $modified = true;
      }
    }
  }
  return $modified;
}

/**
 * Implements hook_css_alter().
 */
function gulpifier_css_alter(&$css) {
  global $theme;

  if (!theme_get_setting('gulpifier')) {
    return;
  }

  $theme_path = drupal_get_path('theme', $theme);

  // We build our whitelist, the whitelist is a list of files that won't be
  // processed by our logic.
  $whitelist = gulpifier_get_whitelist($theme, 'css');

  // Get the bundle style path.
  $style_path = variable_get('gulpifier_css_bundle_path', $theme_path . '/dist') . '/style.min.css';

  // gulpifier_single_css means we work in a production environment, so we
  // analyse the only need our single CSS file
  if (variable_get('gulpifier_single_css', FALSE)) {

    // Here we do a whitelist only on our file and inline CSS
    foreach ($css as $name => $settings) {

      // Special processing for a few CSS items.
      if ($style_path === $name) {
        $css[$name]['preprocess'] = FALSE;
        continue; // This is our file!
      }
      if ($settings['type'] == 'inline') {
        // This will disable @import commands, better for requests
        $css[$name]['preprocess'] = FALSE;
        continue;
      }

      if (gulpifier_match($name, $settings) && !in_array($name, $whitelist, TRUE)) {
        unset($css[$name]);
      }
      else {
        // For the rest, use the same group, to have a single bundle
        $css[$name]['group'] = CSS_DEFAULT;
      }
    }
  }
  else {
    if (isset($css[$style_path])) {
      unset($css[$style_path]);
    }
  }
}

/**
 * Implements hook_process_html().
 */
function gulpifier_process_html(&$vars) {
  // @todo There is a better way to do this.
  if (variable_get('gulpifier_nocachebuster', FALSE) && !stristr($_GET['q'], 'flush-cache')) {
    $vars['styles'] = preg_replace('@\.css\?.*"@U', '.css"', $vars['styles']);
    $vars['scripts'] = preg_replace('@\.js\?.*"@U', '.js"', $vars['scripts']);
  }
}
